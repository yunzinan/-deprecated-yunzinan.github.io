<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>力扣刷题笔记 | Yunzinan</title><meta name="keywords" content="Algorithm"><meta name="author" content="oys"><meta name="copyright" content="oys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LeetCode 刷题笔记 知识学习 C++STL容器学习 vector  变长数组 访问：下表or迭代器 函数：  push_back() pop_back() size() clear() O(N) insert(it, x) O(N) erase(it)  常用函数  1234vector&lt;int&gt; a;n &#x3D; a.size();a.resiz">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣刷题笔记">
<meta property="og:url" content="https://yunzinan.github.io/post/c1c4cec.html">
<meta property="og:site_name" content="Yunzinan">
<meta property="og:description" content="LeetCode 刷题笔记 知识学习 C++STL容器学习 vector  变长数组 访问：下表or迭代器 函数：  push_back() pop_back() size() clear() O(N) insert(it, x) O(N) erase(it)  常用函数  1234vector&lt;int&gt; a;n &#x3D; a.size();a.resiz">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-05-10T11:25:40.000Z">
<meta property="article:modified_time" content="2022-06-11T09:02:40.142Z">
<meta property="article:author" content="oys">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yunzinan.github.io/post/c1c4cec"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '力扣刷题笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-11 17:02:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/doge.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yunzinan</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">力扣刷题笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-10T11:25:40.000Z" title="发表于 2022-05-10 19:25:40">2022-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-11T09:02:40.142Z" title="更新于 2022-06-11 17:02:40">2022-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/">CS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="力扣刷题笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="leetcode-刷题笔记">LeetCode 刷题笔记</h1>
<h2 id="知识学习">知识学习</h2>
<h3 id="cstl容器学习">C++STL容器学习</h3>
<h4 id="vector">vector</h4>
<ul>
<li>变长数组</li>
<li>访问：下表or迭代器</li>
<li>函数：
<ul>
<li>push_back()</li>
<li>pop_back()</li>
<li>size()</li>
<li>clear() O(N)</li>
<li>insert(it, x) O(N)</li>
<li>erase(it)</li>
</ul></li>
<li>常用函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">n = a.<span class="built_in">size</span>();</span><br><span class="line">a.<span class="built_in">resize</span>(n);</span><br><span class="line">a.<span class="built_in">assign</span>(n, val);</span><br></pre></td></tr></table></figure>
<h4 id="string">string</h4>
<ul>
<li>字符串加强版，减少对指针的依赖，集成了一些操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; str[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line">string::iterator it = str.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="string">&quot;opq&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">3</span>, str2);<span class="comment">//输出“abcopqd”</span></span><br><span class="line">str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>(), str2.<span class="built_in">begin</span>(), str2.<span class="built_in">end</span>());<span class="comment">//将另一个str中的某一部分查到指定位置 末尾是指最后一个字符的下一个</span></span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">brgin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">str.<span class="built_in">clear</span>();</span><br><span class="line">string str1 = str2.<span class="built_in">substr</span>(pos, len);</span><br><span class="line">str1.<span class="built_in">find</span>(str2);<span class="comment">//寻找匹配的子串第一次出现的pos，否则返回string::npos</span></span><br></pre></td></tr></table></figure>
<h4 id="stack">stack</h4>
<h4 id="queue">queue</h4>
<ul>
<li>队列 FIFO</li>
<li>函数：
<ul>
<li>push()</li>
<li>pop()</li>
<li>front() back()</li>
<li>bool empty()</li>
<li>size()</li>
</ul></li>
<li>用途：BFS</li>
<li>==注意点==：使用 front() back() pop()
前，必须用empty()判断队列是否为空</li>
</ul>
<h4 id="priority_queue">priority_queue</h4>
<ul>
<li><p>优先队列 用 <strong>堆</strong>实现，
队首元素一定是当前队列中优先级最高的那个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; q_less<span class="comment">//less&lt;int&gt; 表示数字大的优先级越大，即数字越来越小</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q_great<span class="comment">// greater&lt;int&gt; 表示数字小的优先级越大，即数字越来越大</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>==注：在使用top()函数前，必须用empty()判断优先队列是否为空==</p></li>
<li></li>
</ul>
<h4 id="set-unordered_set">set (unordered_set)</h4>
<ul>
<li>set 内部==自动有序==（unordered_set不排序） 不含重复元素</li>
<li>访问 迭代器（地址）</li>
<li>函数
<ul>
<li>insert() O(logN)</li>
<li>find() O(logN)</li>
<li>erase() way1: erase(it) O(1) way2: erase(value) O(logN)
//也可以erase(it, st.end())实现删除一段元素</li>
<li>size() O(1)</li>
<li>clear() O(N)</li>
</ul></li>
<li>主要用处：自动去重&amp;&amp;按升序排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> st;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it; it != st.<span class="built_in">begin</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="map">map</h4>
<ul>
<li>映射：map可以将任何基本类型（包括STL容器）映射到任何基本类型，例如
建立string -&gt; int 的映射</li>
<li>另一种情形：判断给定的一些数字是否在某个文件中出现过。按照正常思路，可以开一个bool类型的hashTable[max_size]，但是当这些数字很大时（例如几千位）这个数组就会开不了。而这时map可以派上用场。将这些数字转换为字符串，然后建立string
-&gt; int 的映射（或是直接建立int -&gt; int 的映射）。</li>
<li>访问：和访问普通数组是一样的。但是需要注意，<strong>map中的键是唯一的</strong>，多次的重复输入将会覆盖之前的value。也可以使用迭代器。</li>
<li>==map会以键从小到大的顺序自动排序==（同样因为其是用红黑树实现的）</li>
<li>函数：
<ul>
<li>find(key) O(logN) 返回地址</li>
<li>erase(it) O(1) || erase(key) O(logN) || erase(first, last)
注意last为==区间末尾迭代器的下一个元素==（美国人喜欢左闭右开）</li>
<li>size() O(1)</li>
<li>clear() O(N)</li>
</ul></li>
<li>用途：任意类型映射 大整数
每个key对应的val唯一（否则用multimap）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map&lt;keyTypeName, valTypeName&gt; mp;//两个类型：key -&gt; val</span></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//输出 a 40 // m 20 // r 30  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="pair">pair</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; a[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">	a[i].first = i;</span><br><span class="line">    a[i].second = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="list">list</h4>
<h3 id="algorithm头文件下的常用函数">algorithm头文件下的常用函数</h3>
<h4 id="sort函数的用法">sort()函数的用法</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort(首元素的地址, 尾元素地址的下一个地址, 比较函数(非必填))</span></span><br><span class="line"><span class="comment">/*bool cmp(比较对象元素的类型 a, b) &#123;</span></span><br><span class="line"><span class="comment">	return 符合排序要求的返回true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//对于int 类型数据的排序</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a+<span class="number">6</span>, cmp_int);<span class="comment">//默认升序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_int</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于char 类型的排序</span></span><br><span class="line"><span class="type">int</span> <span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(s, s+ <span class="number">3</span>, cmp_char);<span class="comment">//默认字典序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_char</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于struct 的排序</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;stru;</span><br><span class="line">stru struc[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//省略初始化内容</span></span><br><span class="line"><span class="built_in">sort</span>(struc, struc+<span class="number">3</span>, cmp_struct);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_struct</span><span class="params">(stru a, stru b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.a != b.a) <span class="keyword">return</span> a.a &gt; b.a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.b &gt; b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对vector&lt;int&gt; 的排序</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">	v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp_vector);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_vector</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="comment">//注意!:因为vector中的元素类型为int</span></span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; vv;</span><br><span class="line"><span class="comment">//省略初始化</span></span><br><span class="line"><span class="built_in">sort</span>(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), cmp_vvector);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">vvector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];<span class="comment">//首先以首元素排序,其次以第二元素排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对string 类型排序</span></span><br><span class="line">string str[<span class="number">3</span>] = &#123;<span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(str, str+<span class="number">3</span>, cmp_str);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_str</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();<span class="comment">//按字符串长度排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==注意：在类中定义cmp函数时要加<strong>static</strong>==</p>
<h4 id="stable_sort用法">stable_sort用法</h4>
<p>stable_sort是稳定排序，而sort是不稳定排序，即相同元素的先后顺序在排序前后可能会发生变化。</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(NlogN) \sim
O(N(logN)^2)\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::stable_sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="comment">//以普通函数的方式实现自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式实现自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式，对 32、71、12、45 进行排序</span></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>); <span class="comment">//(12 32 45 71) 26 80 53 33</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序</span></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//(71 45 32 12) 26 80 53 33</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，通过自定义比较规则进行排序,这里也可以换成 mycomp2()</span></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), mycomp);<span class="comment">//12 26 32 33 45 53 71 80</span></span><br><span class="line">    <span class="comment">//输出 myvector 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lower_bound-upper_bound">lower_bound &amp; upper_bound()</h4>
<ul>
<li><p>lower_bound( )和upper_bound(
)都是利用==二分查找==的方法在一个<strong>排好序</strong>的数组中进行查找的。</p></li>
<li><p>lower_bound(
begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到-返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p></li>
<li><p>upper_bound(
begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), val);\\ 返回第一个大于等于val的迭代器</span><br><span class="line">	<span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(),, v.<span class="built_in">end</span>(), val);\\返回第一个大于val的迭代器</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(a, a+<span class="number">5</span>);</span><br><span class="line">	<span class="type">int</span> idx = <span class="built_in">lower_bound</span>(a, a+<span class="number">5</span>, <span class="number">3</span>);\\返回的是下标</span><br><span class="line">	std::cout &lt;&lt; idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">2</span>*<span class="built_in">int</span>(<span class="number">1e9</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">34</span>&#125;; </span><br><span class="line">	<span class="built_in">sort</span>(num,num+<span class="number">6</span>);                           <span class="comment">//按从小到大排序 </span></span><br><span class="line">	<span class="type">int</span> pos1=<span class="built_in">lower_bound</span>(num,num+<span class="number">6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于或等于被查数的值 </span></span><br><span class="line">	<span class="type">int</span> pos2=<span class="built_in">upper_bound</span>(num,num+<span class="number">6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于被查数的值</span></span><br><span class="line">	cout&lt;&lt;pos1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos1]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;pos2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos2]&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">sort</span>(num,num+<span class="number">6</span>,cmd);                      <span class="comment">//按从大到小排序</span></span><br><span class="line">	<span class="type">int</span> pos3=<span class="built_in">lower_bound</span>(num,num+<span class="number">6</span>,<span class="number">7</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于或等于被查数的值 </span></span><br><span class="line">	<span class="type">int</span> pos4=<span class="built_in">upper_bound</span>(num,num+<span class="number">6</span>,<span class="number">7</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于被查数的值 </span></span><br><span class="line">	cout&lt;&lt;pos3&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos3]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;pos4&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[pos4]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="数据结构">数据结构</h3>
<h4 id="链表">链表</h4>
<h4 id="树">树</h4>
<ul>
<li>概念：<span class="math display">\[node\ leaf\ edge\ child\
subtree\]</span></li>
<li>度（degree）：子树的棵树//最大值为树的度</li>
<li>由于一条边连接两个节点，且树中不存在环，因此对有n个节点的树，边数一定是n
- 1。且满足<strong>连通、边数= 顶点数 -
1的结构一定是一棵树</strong>。</li>
<li>叶子节点：度为0的节点</li>
<li>深度（depth）：自顶向下 高度（height）：自底向上</li>
<li>完全二叉树：满二叉树+只能是右子节点不存在</li>
<li>==注意：新建树/节点后必须初始化其左右子节点的地址为NULL==</li>
</ul>
<h5 id="树的遍历">树的遍历</h5>
<ul>
<li><p>前序遍历（preorder）：根-左-右</p>
<ul>
<li>判断当前节点是否为NULL</li>
<li>访问根节点</li>
<li>递归左子节点</li>
<li>递归右子节点</li>
</ul></li>
<li><p>中序遍历（inorder）：左-根-右</p></li>
<li><p>后序遍历（postorder）：左-右-根</p></li>
<li><p>层序遍历（layerOrder）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> TreeNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;TreeNode *&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">	TreeNode *now = q.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="bst-二叉搜索树">BST 二叉搜索树</h5>
<ul>
<li>定义：左子树上所有节点的数据域均小于或等于根节点的数据域，右子树上所有节点的数据域均大于根节点的数据域。</li>
<li>查找：有点类似二分查找：<strong>左子树&lt;=根节点&lt;右子树</strong></li>
<li>插入：基于查找</li>
<li>性质：对二叉查找树进行中序遍历，遍历的结果是有序的。</li>
</ul>
<h5 id="avl树-平衡二叉树">AVL树 平衡二叉树</h5>
<h5 id="并查集">并查集</h5>
<ul>
<li>合并：合并两个集合，先判断是否为同一个集合，若不是，则把其中一个根节点的父节点指向另一个集合的根节点</li>
<li>查找：判断两个元素是否在同一个集合</li>
<li>代码实现：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> father[N];<span class="comment">//father[i]表示元素i的父节点，若father[i] == i，则说明i为集合的根节点，作为所属集合的标识</span></span><br><span class="line"><span class="comment">//initialize</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    father[i] = i; <span class="comment">//or father[i] = -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//findRecursive</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFatherR</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findFatherR</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//union</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> faA = <span class="built_in">findFather</span>(a);</span><br><span class="line">    <span class="type">int</span> faB = <span class="built_in">findFather</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faB] = faA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="路径压缩">路径压缩</h6>
<p>把当前查询节点的路径上的所有节点的父节点都指向根节点，使得查找时不必一直回溯，查询的复杂度可以降到O(1)。</p>
<p>因此转换的过程可以概括为：</p>
<ol type="1">
<li>按原先的写法获得x的根节点r</li>
<li>重新从x开始走一遍寻找根节点的过程，把路径上经过的所有节点的父节点都改为根节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> remark = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(remark != father[remark]) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = father[remark];</span><br><span class="line">        father[remark] = x;</span><br><span class="line">        remark = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字典树">字典树</h5>
<p>​ 实现前缀匹配，模糊搜索。可以快速的插入和查找</p>
<h5 id="哈夫曼树最优二叉树">哈夫曼树（最优二叉树）</h5>
<p>路径长度：从根节点出发到达该节点所经过的边数。</p>
<p>带权路径长度（weighed path length of tree）：<span
class="math display">\[\sum(叶子节点的权值\times路径长度)\]</span></p>
<p><strong>哈夫曼树的构建思路</strong>：每次合并节点权值最小的两个节点，合并后的节点放回，进行下一次的比较。（图示见下）</p>
<figure>
<img
src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/1468796-20190305104828864-176580657.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>性质：哈夫曼树不存在度为1的节点，并且权值越高的节点相对来说越接近根节点。</p>
<p>哈夫曼编码：可变长编码 减少编码长度</p>
<ol type="1">
<li><p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/liuzeyu12a/p/10475980.html">最优二叉树(赫夫曼树)
- 四季列车 - 博客园</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18V411v7px">【算法】Huffman编码</a></p></li>
</ol>
<h4 id="栈">栈</h4>
<h4 id="队列">队列</h4>
<h4 id="树状数组">树状数组</h4>
<blockquote>
<blockquote>
<p>引入：考虑一个单点修改、区间求和的问题。</p>
<p>若采用朴素算法，</p>
<p>​ 单点修改：O(1)</p>
<p>​ 区间查询：O(N)</p>
<p>若采用前缀和，</p>
<p>​ 单点修改：O(N)</p>
<p>​ 区间查询：O(1)</p>
</blockquote>
</blockquote>
<p>引入树状数组，使得修改和查询的复杂度都为O(logN)</p>
<h5 id="预备知识lowbit运算">预备知识：lowbit()运算</h5>
<p>非负整数 <span class="math inline">\(n\)</span>
==在二进制表示下最低位 1 及其后面的 0 构成的数值== <span
class="math display">\[
\begin{aligned}
\sim n+1=-n &amp;(\sim \text { 表示取反 }) \\
\operatorname{lowbit}(n) &amp;=n \&amp;(\sim n+1) \\
&amp;=n \&amp;-n
\end{aligned}
\]</span> <img
src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220404144542976.png"
alt="image-20220404144542976" /></p>
<p>树状数组的性质</p>
<ul>
<li><p><span class="math display">\[
c[x]存储(x-lowbit(x),x]的和
\]</span></p></li>
<li><p>```c++ int sum = 0; for(int i = x; i &gt; 0; i -= lowbit(i)) {
sum += c[i]; } <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">#### 哈希（散列） </span><br><span class="line"></span><br><span class="line">- definition: Hash Table is a data structure to map key to values (also called Table or Map Abstract Data Type/ADT). It uses a **hash function** to map large or even non-Integer keys into a small range of Integer indices (typically [0..hash_table_size-1]).</span><br><span class="line"></span><br><span class="line">  The probability of two distinct keys colliding into the same index is [relatively high](https://visualgo.net/zh/hashtable?slide=3-5) and each of this potential collision needs to be resolved to maintain ==data integrity==（数据可靠性）.</span><br><span class="line"></span><br><span class="line">  There are several collision resolution strategies that will be highlighted in this visualization: Open Addressing (Linear Probing, Quadratic Probing, and Double Hashing) and Closed Addressing (Separate Chaining).</span><br><span class="line"></span><br><span class="line">  [来源]（[哈希表（开放寻址法：线性探测，二次探测，双倍散列 以及 闭散列分离连接法） - VisuAlgo](https://visualgo.net/zh/hashtable?slide=1)）</span><br><span class="line"></span><br><span class="line">- 哈希的本质是一个数组：</span><br><span class="line"></span><br><span class="line">  - 数组+链表</span><br><span class="line">  - 数组+BST(冲突比较多时，降低存储效率以换取查找效率)</span><br><span class="line"></span><br><span class="line">- 哈希冲突的解决方法：</span><br><span class="line"></span><br><span class="line">  - 拉链法</span><br><span class="line">  - 开放寻址法</span><br><span class="line"></span><br><span class="line">- 哈希的核心是哈希函数</span><br><span class="line"></span><br><span class="line">- 如何理解哈希表？（hashTable）</span><br><span class="line"></span><br><span class="line">  - 例：QQ群列表里找某个人？逐个找（遍历）？太慢！</span><br><span class="line">  - 策略：按照昵称首字母a-z排序，例如昵称为Jack_shen的，直接在$j$中查找即可。</span><br><span class="line">  - 注意到这里我们对输入的数据（Jack_shen）进行了某种运算（取首字母），得到了对应的key($j$)，相当于将所有的输入的字符串分为26个堆来存放，这样查找时根据这个算法再次计算得到其所在的key，只需在这个堆中进行遍历即可。</span><br><span class="line"></span><br><span class="line">- 键值对：一个值对应另外一个值（key -&gt; value）key叫做键值，value叫做哈希值</span><br><span class="line"></span><br><span class="line">- 如何理解哈希映射？（hashMap）</span><br><span class="line"></span><br><span class="line">#### 优先队列（堆）</span><br><span class="line"></span><br><span class="line">- 优先队列（priority queue）。实现的功能就是**取出一堆数字中的最大数或者最小数**，以最小数放在堆顶为例，如果维护一个链表，那么添加元素的复杂度为O（1），但是查找元素的复杂度为O（N），我们必须遍历链表的每一个元素才可以找到其中的最小值；如果维护一个普通的单调数组，这样的话插入的复杂度为O（N），查找的复杂度为O(1)，所以一种折衷的方案是使用高度平衡的二叉树，由于其结构完全确定，我们其实可以只用一个数组来储存，但并不破坏其二叉树的本质。</span><br><span class="line"></span><br><span class="line">  令数组下标从1开始，会有1|2 3|4 5 6 7|... 父节点到子节点有这样的关系：</span><br><span class="line">  $$</span><br><span class="line">  root&amp;x\\ leftLeaf&amp;2x\\ rightLeaf&amp;2x+1</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">​		所以我们可以据此推断出任意一个节点的父节点和子节点。</span><br><span class="line"></span><br><span class="line">- 堆的添加元素</span><br><span class="line"></span><br><span class="line">![image-20220217223136977](https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220217223136977.png)</span><br><span class="line"></span><br><span class="line">- 堆的删除元素</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220217223412247.png&quot; alt=&quot;image-20220217223412247&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- 实现代码</span><br><span class="line"></span><br><span class="line">#### 图</span><br><span class="line"></span><br><span class="line">- 图的属性：</span><br><span class="line"></span><br><span class="line">  - 边（edge）：有向图/无向图、边权</span><br><span class="line"></span><br><span class="line">  - 点（vertex）：出度/入度、边权</span><br><span class="line"></span><br><span class="line">  - ==注==：图的抽象：边就是“关系”，点就是“状态”</span><br><span class="line"></span><br><span class="line">  - **连通分量**：在**无向图**中，如果两个顶点之间可以相互到达，那么就称这两个顶点连通。如果图中任意两个顶点都连通，则称为连通图；否则成为非连通图，其中，极大的连通子图为连通分量。</span><br><span class="line"></span><br><span class="line">  - **强连通分量**：在**有向图**中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，那么九称这两个顶点强连通。如果任意两点都强连通，则称为强连通图，否则，称为非强连通图，其中极大强连通子图为强连通分量。</span><br><span class="line"></span><br><span class="line">  - 为了叙述的方便，将连通分量和强连通分量称为**连通块**。</span><br><span class="line"></span><br><span class="line">##### 图的存储：</span><br><span class="line"></span><br><span class="line">- 邻接表</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">    bool graph[N][N];</span><br><span class="line">    //if(graph[i][j] == n) it means that i-j has an edge with the value of n</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>​</p>
<ul>
<li>邻接矩阵</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usually implemented by Node List or vector</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>链式前向星</li>
<li></li>
</ul>
<h5 id="图的遍历深搜dfs">图的遍历：深搜（DFS）</h5>
<pre><code>- 每次总是沿着路径到不能再前进时才退回到最近的岔道口

- 具体实现：</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">```c++</span><br><span class="line">//pseudo</span><br><span class="line">DFS(u) &#123;//visit vertex u</span><br><span class="line">    vis[u] = true;</span><br><span class="line">    for(从u出发能到达的所有顶点v) &#123;</span><br><span class="line">        if(vis[v] == false) &#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G) &#123;// traverse G</span><br><span class="line">    for(G的所有顶点u) &#123;</span><br><span class="line">        if(vis[u] == false) &#123;</span><br><span class="line">            DFS(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//邻接矩阵版</span><br><span class="line">#define MAXV 1000</span><br><span class="line">#define INF 1000000000</span><br><span class="line">int n, G[MAXV][MAXV];</span><br><span class="line">bool vis[MAXV] = &#123;false&#125;;</span><br><span class="line"></span><br><span class="line">void DFS(int u, int depth) &#123;</span><br><span class="line">    vis[u] = true;</span><br><span class="line">    for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">        if(vis[v] == false &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">            DFS(v,depth+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFSTrave() &#123;</span><br><span class="line">    for(int u = 0; u &lt; n; u++) &#123;</span><br><span class="line">        if(vis[u] == false) &#123;</span><br><span class="line">            DFS(u, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//邻接表版</span><br><span class="line">vector&lt;int&gt; adj[MAXV];</span><br><span class="line">int n;</span><br><span class="line">bool vis[MAXV] = &#123;false&#125;;</span><br><span class="line"></span><br><span class="line">void DFS(int u, int depth) &#123;</span><br><span class="line">    vis[u] = true;</span><br><span class="line">    for(int i = 0; i &lt; adj.size(); i++) &#123;</span><br><span class="line">        int v = adj[u][i];</span><br><span class="line">        if(vis[v] == false) &#123;</span><br><span class="line">            DFS(v, depth+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFSTrave() &#123;</span><br><span class="line">    for(int u = 0; u &lt; n; u++) &#123;</span><br><span class="line">        if(vis[u] == false) &#123;</span><br><span class="line">            DFS(u,1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>​</p>
<h5 id="图的遍历广搜bfs">图的遍历：广搜（BFS）</h5>
<h5 id="图的遍历a算法">图的遍历：<span
class="math inline">\(A^*\)</span>算法</h5>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bv411y79P?spm_id_from=333.337.search-card.all.click">A*寻路算法详解
#A星 #启发式搜索_哔哩哔哩_bilibili</a></p>
<h5 id="最小生成树-minimal-spanning-tree-prim算法">最小生成树 (Minimal
Spanning Tree) ：prim算法</h5>
<blockquote>
<blockquote>
<p><strong>Tree vs. Graphs</strong></p>
<ol type="1">
<li>Trees are undirected graphs.</li>
<li>Trees do not have circles(acyclic).</li>
</ol>
<p>So, how to turn a graph into a tree?</p>
<ul>
<li>Keep all the n vertices.</li>
<li>Keep exactly n-1 edges.(not connected if less, has circle(s) if
more.)</li>
<li>It's impossible to turn a disconnected graph into a tree.</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><p>Definition of MST: the spanning tree with the minimum sum of
weights.</p></li>
<li><p><strong>Basic idea: grow the tree in successive
stages.</strong></p></li>
<li><p>In each iteration, add one vertex and one edge to the
tree.</p></li>
<li><p>Thoroghout, maintain the properties of trees.</p>
<ul>
<li>Connectivity</li>
<li>No circle</li>
</ul></li>
<li><p>The algorithm runs in <span class="math inline">\(|V|\)</span>
iterations.</p></li>
<li><p>Maintenance:</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; selected[N] <span class="comment">//place all the vertices that has alreay been linked.</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; unselected[N] <span class="comment">//temporally not selected vertices</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><p>Procedures:</p>
<ul>
<li><p>Update</p>
<p>Update all the vertices that the current vertex is connected to,
if</p></li>
<li><p>Scan</p></li>
<li><p>Add</p></li>
</ul></li>
</ul>
<h5 id="最小生成树mstkruskal算法">最小生成树（MST）：Kruskal算法</h5>
<h5 id="单源最短路径dijkstra算法">单源最短路径：Dijkstra算法</h5>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=EFg3u_E6eHU">How Dijkstra's
Algorithm Works - YouTube</a></p>
<ul>
<li><p>思路：可以证明，路径<span class="math inline">\(P_i\rightarrow
...\rightarrow P_k\rightarrow ...\rightarrow
P_j\)</span>的最短路径为从i到k的最短路径+从k到j的最短路径，因此要想找到从i到j的最短路径，需要依次找到到其之前各节点的最段路径。</p></li>
<li><p>维护：</p>
<ul>
<li>vis[n]
将所有的节点分为“已找到最短路径的节点”和“尚未找到的”，后者不断转化为前者</li>
<li>dis[n] 表示在当前阶段 从源节点到i的最短路径</li>
<li>fa[n] 表示这条“当前最优”的路径下i的前一个节点</li>
</ul></li>
<li><p>步骤：</p>
<ul>
<li>初始化（建立邻接表、初始化几个维护的数组、fa[src] = src, vis[src] =
true, dis[src] = 0）</li>
<li>循环USA(for int t = 1; t &lt; vertices.size(); i++)
<ul>
<li>Update
更新当前节点能到达的所有尚未找到最短路径的点的最短路径（如果更短的话），这一步维护dis[n]
fa[n]</li>
<li>Scan 找到所有尚未找到最短路径的节点中距离最短的点</li>
<li>Add
这个点的当前最段路径必为最短路径，因此将其加入“已经找到最短路径”的集合中，这一步维护
vis[n]</li>
</ul></li>
</ul></li>
</ul>
<h5 id="拓扑排序">拓扑排序</h5>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489706&amp;idx=1&amp;sn=771cd807f39d1ca545640c0ef7e5baec">【拓扑排序】图论拓扑排序入门
(qq.com)</a></p>
<p>Directed Acyclic Graphs(DAG) The only type of graph which has a valid
topological ordering is a Directed Acyclic Graph (DAG). These are graphs
with directed edges and no cycles.</p>
<p>Q: How do I verify that my graph does not contain a directed
cycle?</p>
<p>A: One method is to use Tarjan's strongly connected component
algorithm which can be used to find these cycles.</p>
<blockquote>
<blockquote>
<p>拓扑排序实际上应用的是贪心算法。贪心算法简而言之：每一步最优，全局就最优。</p>
<p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为
00
的结点，并移除它、修改它指向的结点的入度（-1−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p>
<p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有
AOV 网，这里就不展开了。</p>
<p>算法流程：</p>
<p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 00
的结点放入队列。</p>
<p>2、只要队列非空，就从队首取出入度为 00
的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减
11，在减 11 以后，如果这个被减 11 的结点的入度为 00 ，就继续入队。</p>
<p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p>
<p>思考这里为什么要使用队列？（马上就会给出答案。）</p>
<p>在代码具体实现的时候，除了保存入度为 0
的队列，我们还需要两个辅助的数据结构：</p>
<p>1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；</p>
<p>2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。</p>
<p>这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。</p>
</blockquote>
</blockquote>
<h5 id="强连通分量求法tarjan算法">强连通分量求法：Tarjan算法</h5>
<p>[<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19J411J7AZ?p=3">算法]轻松掌握tarjan强连通分量_哔哩哔哩_bilibili</a></p>
<h5 id="图中是否存在环的判断">图中是否存在环的判断</h5>
<ul>
<li>有向图：拓扑排序</li>
<li>无向图：并查集</li>
</ul>
<h3 id="算法">算法</h3>
<h4 id="排序和搜索">排序和搜索</h4>
<h4 id="二分查找">二分查找</h4>
<ul>
<li>利用二分对象的<strong>单调性</strong>，
每次查找将查询空间折半，使得复杂度为O(logN)</li>
<li>二分的难点不在于实现，而是想到要二分，想到对谁进行二分，要利用好这个单调性。</li>
</ul>
<h4 id="dp">dp</h4>
<blockquote>
<blockquote>
<p>我们是如何确定本题可以使用动态规划来解诀的?
通常我们要从「有无后效性」进行入手分析。
如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性
的问题，可以考虑使用 DP 解决。 另外一个更加实在的技巧，我们还可以通过
数据范围来猜测是不是可以用 DP 来做。 因为 DP
是一个递推的过程，因此如果数据范围是 <span class="math inline">\(10^{5}
\sim 10^{6}\)</span> 的话，可以考虑是不是可以使用一维 DP 来解决；如果
数据范围是 <span class="math inline">\(10^{2} \sim 10^{3}\)</span>
的话，可以考虑是不是可以使用二维 DP 来做 ...</p>
</blockquote>
<blockquote>
<p>我们是如何确定本题的状态定义的? 说实话，DP
的状态定义很大程度是靠经验去猜的。
虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联的。</p>
</blockquote>
<p><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/rtd7d2/">DP
- 路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台
(leetcode-cn.com)</a></p>
</blockquote>
<h4 id="蓄水池抽样">蓄水池抽样</h4>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247490892&amp;idx=1&amp;sn=c1fe373edc88142cbabd383ef3c0669b">【蓄水池抽样】多语言入门蓄水池抽样</a></p>
<p>整理题意：总的样本数量末知,
从所有样本中抽取若干个，要求每个样本被抽到的概率相等。 具体做法为:
从前往后处理每个样本, 每个样本成为答案的概率为 <span
class="math inline">\(\frac{1}{i}\)</span>, 其中 <span
class="math inline">\(i\)</span> 为样本编号 (编号从 1 开始),
最终可以确保每个样本成为答案的概率均为 <span
class="math inline">\(\frac{1}{n}\)</span> (其中 <span
class="math inline">\(n\)</span> 为样本总 数）。 容易证明该做法的正确性,
假设最终成为答案的样本编号为 <span class="math inline">\(k\)</span>,
那么 <span class="math inline">\(k\)</span> 成为答案的充要条件
为「在遍历到 <span class="math inline">\(k\)</span>
时被选中」并且「遍历大于 <span class="math inline">\(k\)</span>
的所有元素时, 均没有被选择（没有覆盖 <span
class="math inline">\(k\)</span> ) <span class="math inline">\(\perp
。\)</span> 对应事件概率为: <span class="math display">\[
P=\frac{1}{k} *\left(1-\frac{1}{k+1}\right)
*\left(1-\frac{1}{k+2}\right) * \ldots *\left(1-\frac{1}{n}\right)
\]</span> 首项 <span class="math inline">\(\frac{1}{k}\)</span> 为选中
<span class="math inline">\(k\)</span> 的概率, 后面每项分别为编号为
<span class="math inline">\([k+1, n]\)</span> 的样本「不被选中」的概率。
化简得: <span class="math display">\[
P=\frac{1}{k} * \frac{k}{k+1} * \frac{k+1}{k+2} * \ldots * \frac{n-1}{n}
\]</span> 进一步抵消化简后, 可得: <span class="math display">\[
P=\frac{1}{n}
\]</span> 因此, 在每一次 getrandom 时, 从前往后处理每个节点,
同时记录当前节点的编号, 当处 理到节点 <span
class="math inline">\(k\)</span> 时, 在 <span class="math inline">\([0,
k)\)</span> 范围内进行随机, 若随机到结果为 0 (发生概率为 <span
class="math inline">\(\frac{1}{k}\)</span> ), 则将节点 <span
class="math inline">\(k\)</span> 的值存入答案,
最后一次覆盖答案的节点即为本次抽样结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* head;</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* _head) &#123;</span><br><span class="line">        head = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> t = head;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">rand</span>() % idx == <span class="number">0</span>) ans = t-&gt;val;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用蓄水池算法，用通俗的语言说一下：</p>
<ul>
<li>如果我们池子中只有一个数字，那么拿到第一个数字的概率就是100%毋庸置疑。</li>
<li>两个数字50% 三个数字每个数字的几率都是33% 以此类推。。。。</li>
</ul>
<p>当我们不知道池子里有多少个数字的时候，就需要用蓄水池的算法思想去计算。</p>
<ul>
<li>当链表前行到第一个数字，此时取第一个数字的几率为100%，那result自然等于这个数字。</li>
<li>前进到第二个数字，那么此时取这个数字的几率自然就为50%（池子里只有两个数字），那么就是50%的几率取新数字，50%的几率保留原本的数字。</li>
<li>第三个数字的时候，33%的几率取当前最新的这个数字，66%的几率保留原本的数字。这66%中：原本的数字有50%的几率是1，有50%的几率是2。也就是此时三个数字的概率都为33%。
通过这个算法，就能达到取数的概率均摊，从而实现随机。</li>
</ul>
<h2 id="刷题记录补充知识做题经验">刷题记录（补充知识+做题经验）</h2>
<h4 id="二分check">二分+check</h4>
<h5 id="lc5219-每个小孩最多能分到多少糖果"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/">LC5219
每个小孩最多能分到多少糖果</a></h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : a) </span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="comment">/* low分得最少糖果数目，high分得最多糖果数目 */</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> low = <span class="number">0</span>, high = sum / k;</span><br><span class="line">        <span class="keyword">while</span> (low != high) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (low + high + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">// 二分糖果数目</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> heap = <span class="number">0</span>;<span class="comment">// 按照每堆糖果数为mid的糖果一共可以分多少堆</span></span><br><span class="line">            <span class="comment">/* 更新堆的个数 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : a) </span><br><span class="line">               heap += num / mid;</span><br><span class="line">            <span class="comment">/* 判断按当前糖果数分的对数和孩子个数进行判断 */</span></span><br><span class="line">            <span class="keyword">if</span> (heap &lt; k)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="栈-1">栈</h4>
<h5 id="lc150-逆波兰表达式求值">LC150 逆波兰表达式求值</h5>
<ul>
<li>逆波兰表达式（Reverse Polish Notation）<span
class="math display">\[e.g.\]</span>==后缀表达式（Suffix
Expression）==</li>
<li>表达式由操作数（operand）、运算符（operator）组成，一般将运算符放在两个操作数之间，被称为（Infix
Expression），如A+B。波兰数学家提出了另一种数学表示法，由两种表示形式：前缀、后缀。</li>
<li>算法：以表达式<span
class="math inline">\(1\times(2+3)\)</span>为例，维护两个栈：运算符号栈，后缀表达式输出栈。</li>
<li>首先从左至右扫描表达式，遇到操作数直接压入出栈，若读取的为操作数，则按照以下规则压入入栈。</li>
<li><img
src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/image-20220210224140687.png" /></li>
<li>​
整个过程分为两步：1.将中缀表达式转化为后缀表达式（利用入栈）；2。逐步计算后缀表达式（利用出栈）</li>
</ul>
<h4 id="并查集-1">并查集</h4>
<h5 id="lc547-省份数量">LC547 省份数量</h5>
<p>经典并查集题目，有很多别名（朋友圈、城市连接问题），套模板即可：</p>
<ul>
<li>int findFather() //路径压缩，不做也能过，但是慢一些</li>
<li>void Union()</li>
</ul>
<h5 id="lc1319-连通网络的操作次数"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">LC1319
连通网络的操作次数</a></h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> fa[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> rk[<span class="number">100001</span>];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; vertices;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> index_a, <span class="type">int</span> index_b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> root_a = index_a;</span><br><span class="line">        <span class="keyword">while</span>(fa[root_a] != root_a) root_a = fa[root_a];</span><br><span class="line">        <span class="type">int</span> root_b = index_b;</span><br><span class="line">        <span class="keyword">while</span>(fa[root_b] != root_b) root_b = fa[root_b];</span><br><span class="line">        <span class="keyword">if</span>(root_a == root_b) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rk[root_a] == rk[root_b]) &#123;</span><br><span class="line">            rk[root_a]++;</span><br><span class="line">            fa[root_b] = root_a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rk[root_a] &lt; rk[root_b]) &#123;</span><br><span class="line">            fa[root_a] = root_b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> fa[root_b] = root_a;</span><br><span class="line">    &#125;<span class="comment">// union with rank</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> root = index;</span><br><span class="line">        <span class="keyword">while</span>(fa[root] != root) root = fa[root];</span><br><span class="line">        <span class="keyword">while</span>(index != root) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = fa[index];</span><br><span class="line">            fa[index] = root;</span><br><span class="line">            index = tmp;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;<span class="comment">//compress</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ini</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            rk[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">makeConnected</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> edgeSize = connections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">ini</span>(n);</span><br><span class="line">        <span class="type">int</span> cntE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> index_a = connections[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> index_b = connections[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Find</span>(index_a)!= <span class="built_in">Find</span>(index_b)) <span class="built_in">Union</span>(index_a, index_b);<span class="comment">//***</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cntE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cntV = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vertices.<span class="built_in">find</span>(<span class="built_in">Find</span>(i)) == vertices.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                cntV++;</span><br><span class="line">                vertices.<span class="built_in">insert</span>(<span class="built_in">Find</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cntV &lt;= cntE) <span class="keyword">return</span> cntV;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>==注意：***处不可以写成fa[index_a] ==
fa[index_b]，原因是在并查集中，即使在一个树中，不同子节点的根节点在Find()之前不一定是相同的！！==</p>
<h4 id="二叉树">二叉树</h4>
<h5 id="lc889-根据前序和后序遍历构造二叉树">LC889
根据前序和后序遍历构造二叉树</h5>
<p>此题要求对前序、后序遍历有比较深的理解。它们都具有清晰的<strong>递归</strong>结构。需要注意到二叉树的前序、后序遍历<strong>对应在数组中的结构特性</strong>。</p>
<p>前序遍历数组：根节点-树的左半部分-树的右半部分</p>
<p>后序遍历数组：树的左半部分-树的右半部分-根节点</p>
<p>而”树的左/右半部分”又可以视作一棵子树，从而实现递归，直到子数组的长度为1（递归边界）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">buildTree</span>(root, preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, postorder, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;pre, <span class="type">int</span> preL, <span class="type">int</span> preR, vector&lt;<span class="type">int</span>&gt; &amp;post, <span class="type">int</span> postL, <span class="type">int</span> postR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(preL == preR) &#123;<span class="comment">//只有一个节点了</span></span><br><span class="line">            root-&gt;val = pre[preL];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不止一个节点 说明至少存在一个子节点</span></span><br><span class="line">        root-&gt;val = pre[preL];</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        preL++;<span class="comment">//preL 指向左子节点</span></span><br><span class="line">        <span class="keyword">while</span>(postR &lt; post.<span class="built_in">size</span>() &amp;&amp; post[postR] != pre[preL]) &#123;<span class="comment">//找到左子节点在后序中的位置，该位置前的节点都是其子节点</span></span><br><span class="line">            postR++;</span><br><span class="line">        &#125;<span class="comment">//postR - postL = 左子节点的子节点数</span></span><br><span class="line">        root-&gt;left = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        <span class="type">int</span> preLR = preL + postR - postL;<span class="comment">//分割点：左区间的右端点</span></span><br><span class="line">        <span class="built_in">buildTree</span>(root-&gt;left, pre, preL, preLR, post, postL, postL);</span><br><span class="line">        preL = preLR + <span class="number">1</span>;<span class="comment">//preL移动至右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR) &#123; <span class="comment">//超了，说明没有右节点</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;right = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        postL = postR+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(postR &lt; post.<span class="built_in">size</span>() &amp;&amp; post[postR] != pre[preL]) &#123;</span><br><span class="line">            postR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">buildTree</span>(root-&gt;right, pre, preL, preR, post, postL, postL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字典树-1">字典树</h4>
<h5 id="lc440-字典序的第k小数字"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">LC440
字典序的第K小数字</a></h5>
<p>算法思路</p>
<ul>
<li>画出字典树</li>
<li><span class="math inline">\(k\)</span> 表示要找到后面的第 <span
class="math inline">\(k\)</span> 个元素，起始下标是 0</li>
<li>获取以prefix开头的数字个数，包括他本身 。 如果数字个数大于 <span
class="math inline">\(k\)</span> ，下移，在prefix <span
class="math inline">\(* 10\)</span> 下的子树进行查找 。
如果数字个数小于等于 <span class="math inline">\(k\)</span>
，右移，在prefix+1下的子树进行查找 问题的关键是求解
以prefix开头的数字个数，包括他本身</li>
<li>根节点 [prefix, prefix+1 )</li>
<li>第一层 <span class="math inline">\([\operatorname{prefix} *
10,(\operatorname{prefix+1)*10)}\)</span></li>
<li>第二层 [prefix*100, <span class="math inline">\(\min (\mathrm{n}+1,
\quad(\mathrm{prefix}+1) * 100 ）)\)</span></li>
<li>...</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prefix = <span class="number">1</span>;</span><br><span class="line">        k--; <span class="comment">// k记录要找的数字在prefix后的第几个</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">getCnt</span>(n, prefix); <span class="comment">// 当前prefix 下有多少个元素;包含prefix</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= k) &#123; <span class="comment">// 向右</span></span><br><span class="line">                k -= cnt;</span><br><span class="line">                prefix++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向下</span></span><br><span class="line">                k--;</span><br><span class="line">                prefix*=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCnt</span><span class="params">(LL n, LL prefix)</span></span>&#123;</span><br><span class="line">        LL cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LL first = prefix, second = prefix+<span class="number">1</span>; first&lt;=n; first*=<span class="number">10</span>, second*=<span class="number">10</span>)&#123;</span><br><span class="line">            cnt+= <span class="built_in">min</span>(n + <span class="number">1</span>, second) - first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：muyids</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/dfsmo-ni-jian-zhi-guo-cheng-by-muyids/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<h4 id="图">图</h4>
<h5 id="出度入度">出度、入度</h5>
<h6 id="lc997-找到小镇的法官"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-town-judge/">LC997
找到小镇的法官</a></h6>
<blockquote>
<p>本题需要用到有向图中节点的==入度和出度==的概念。在有向图中，一个节点的入度是指向该节点的边的数
量；而一个节点的出度是从该节点出发的边的数量。 思胳及解法
题干描述了一个有向图。每个人是图的节点， trust 的元素 trust[i]
是图的有向边，从 trust [i][0] 指向 trust[i][1]。我们可以遍历
trust，统计每个节点的入度和出度，存储在 inDegrees 和 outDegrees 中。
根据题意，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名
法官。因此法官这个节点的入度是 <span class="math inline">\(n-1\)</span>,
出度是 0 。
我们可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我
们可以直接返回结果；如果不存在符合条件的点，则返回 <span
class="math inline">\(-1\)</span> 。</p>
</blockquote>
<h5 id="bfs">BFS</h5>
<h6 id="lc417-太平洋大西洋水流问题"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">LC417
太平洋大西洋水流问题</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; P, A, ans;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        n = M.<span class="built_in">size</span>(), m = M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        P = A = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//左右两边加上下两边出发深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">dfs</span>(M, P, i, <span class="number">0</span>), <span class="built_in">dfs</span>(M, A, i, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="built_in">dfs</span>(M, P, <span class="number">0</span>, j), <span class="built_in">dfs</span>(M, A, n - <span class="number">1</span>, j);             </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; M, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(P[i][j] &amp;&amp; A[i][j]) ans.<span class="built_in">push_back</span>(&#123;i,j&#125;); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//上下左右深搜</span></span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; M[i<span class="number">-1</span>][j] &gt;= M[i][j]) <span class="built_in">dfs</span>(M, visited, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; n &amp;&amp; M[i+<span class="number">1</span>][j] &gt;= M[i][j]) <span class="built_in">dfs</span>(M, visited, i+<span class="number">1</span>, j); </span><br><span class="line">        <span class="keyword">if</span>(j<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; M[i][j<span class="number">-1</span>] &gt;= M[i][j]) <span class="built_in">dfs</span>(M, visited, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> &lt; m &amp;&amp; M[i][j+<span class="number">1</span>] &gt;= M[i][j]) <span class="built_in">dfs</span>(M, visited, i, j+<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="lc934-最短的桥"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-bridge/">LC934
最短的桥</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; points;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> x = i + direction[k];</span><br><span class="line">            <span class="type">int</span> y = j + direction[k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">                <span class="comment">// 收集这个岛屿附近的0</span></span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="number">0</span>) points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 找到第一个岛屿</span></span><br><span class="line">        <span class="type">bool</span> isFind = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFind) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用dfs把这个岛屿都标志为2</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找另一个岛屿 BFS</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!points.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = points.<span class="built_in">size</span>();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = points.<span class="built_in">front</span>();</span><br><span class="line">                points.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 把这一层的0全部填为2，再把外层的0再加入队列，逐层填陆地，直到碰到第二片岛屿</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> p = x + direction[k];</span><br><span class="line">                    <span class="type">int</span> q = y + direction[k + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (p &gt;= <span class="number">0</span> &amp;&amp; p &lt; m &amp;&amp; q &gt;= <span class="number">0</span> &amp;&amp; q &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[p][q] == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                        <span class="keyword">if</span> (grid[p][q] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        points.<span class="built_in">push</span>(&#123;p, q&#125;);</span><br><span class="line">                        grid[p][q] = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：carpe-diem-ew</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/shortest-bridge/solution/bfs-tian-hai-zao-lu-ti-jie-si-lu-by-carp-6w8j/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>
<h5 id="dijkstra--single-source-shortest-pathsssp-algorithm">Dijkstra-
Single Source Shortest Path(SSSP) algorithm</h5>
<h6 id="lc743-网络延迟时间"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/network-delay-time/">LC743
网络延迟时间</a></h6>
<p>第一次实现dijskstra。总之只要记得USA就行：）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 10000000</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">101</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dis[<span class="number">101</span>];</span><br><span class="line">    <span class="type">int</span> fa[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; grid[<span class="number">101</span>];<span class="comment">//the path len from i to j</span></span><br><span class="line">    <span class="type">int</span> size[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; times, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;<span class="comment">//caculate all minimum path form k to else, and return the biggest</span></span><br><span class="line">        <span class="comment">//ini</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dis[i] = INF;</span><br><span class="line">            fa[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">        fa[k] = k;</span><br><span class="line">        dis[k] = <span class="number">0</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; times.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; temp = &#123;times[i][<span class="number">1</span>]<span class="number">-1</span>, times[i][<span class="number">2</span>]&#125;;</span><br><span class="line">            grid[times[i][<span class="number">0</span>]<span class="number">-1</span>].<span class="built_in">push_back</span>(temp);</span><br><span class="line">            size[times[i][<span class="number">0</span>]<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = k;<span class="comment">//the number of the point now</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>; m &lt; n; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; size[cur]; t++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[grid[cur][t].first]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[cur] + grid[cur][t].second &lt; dis[grid[cur][t].first]) &#123;</span><br><span class="line">                    dis[grid[cur][t].first] = dis[cur] + grid[cur][t].second;</span><br><span class="line">                    fa[grid[cur][t].first] = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//update</span></span><br><span class="line">            <span class="type">int</span> min = INF+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> minV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[i] &lt; min) &#123;</span><br><span class="line">                    min = dis[i];</span><br><span class="line">                    minV = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//scan for the min unsettled v</span></span><br><span class="line">            <span class="keyword">if</span>(min != INF) &#123;</span><br><span class="line">                vis[minV] = <span class="literal">true</span>;</span><br><span class="line">                cur = minV;<span class="comment">//update</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] &gt; ret) ret = dis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表">哈希表</h4>
<h5 id="lc599-两个列表的最小索引总和"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">LC599
两个列表的最小索引总和</a></h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; list1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            hashMap[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minIndex = <span class="number">100000</span>;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; list2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.<span class="built_in">find</span>(list2[i]) != hashMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i + hashMap[list2[i]] &lt; minIndex) &#123;</span><br><span class="line">                    ret.<span class="built_in">clear</span>();</span><br><span class="line">                    string tmp = list2[i];</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                    minIndex = i + hashMap[list2[i]];</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i + hashMap[list2[i]] ==  minIndex) &#123;</span><br><span class="line">                    string tmp = list2[i];</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dp-1">dp</h4>
<h5 id="lc1575-统计所有可行路径"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-all-possible-routes/">LC1575
统计所有可行路径</a></h5>
<ul>
<li><p>解析： <a
target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/path-problems-in-dynamic-programming/r8m6e7/">DP
- 路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台
(leetcode-cn.com)</a></p></li>
<li><p>做题反思：</p>
<ul>
<li>花了很多时间思考：什么是状态？什么是子问题？怎么写状态转移方程？</li>
<li>思考的方式就是试探，有一些想法，带进去看能不能套用动态规划</li>
<li>有一个想法：所有的点实际上分为两类，记为强点和弱点。由于距离是一维的哈密顿距离，因此将所有的点在数轴上表示，会发现<span
class="math inline">\(例如[1,2,3],1\rightarrow3 和
1\rightarrow2\rightarrow3\)</span>花费的是同样的油量。也就是说两点内部插入点，是不改边方法数的，只有新加入的点在之前点的两端才会增加油耗。然而这样想的问题在于每一次新加入的点是强点还是弱点是只取决于上一段路径的，因此需要保存上一次的路径，这样就反而变得复杂了。</li>
<li>我的状态转移的想法是：一开始只有起点和终点，然后不断加入新的点，进行状态转移。然而没有想清楚。</li>
</ul></li>
</ul>
<h4 id="凸包算法">凸包算法</h4>
<p>[<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1v741197YM?spm_id_from=333.337.search-card.all.click">计算几何]Graham算法构造凸包（重制）_哔哩哔哩_bilibili</a></p>
<h3 id="技巧">技巧</h3>
<h4 id="读题与分析">读题与分析</h4>
<ul>
<li>看完题意后，看题目的数据量级</li>
</ul>
<p><span class="math display">\[
1)&amp;\ n\leq10^4 \Rightarrow O(N^2)\\
2)&amp;\ 10^5\leq n\leq 10^6(10^7) \Rightarrow O(NlogN)\\
3)&amp; n \geq 10^8 \Rightarrow O(N)
\]</span></p>
<ul>
<li><p>出现<span class="math inline">\(O(logN)\)</span> 的情形：</p>
<ul>
<li>数据结构（树、堆）</li>
<li>算法（Kruskal Dijkstra
线段树）其实还是化归到数据结构，或者说利用数据结构进行优化</li>
<li>==二分==</li>
<li>==数位运算==</li>
</ul></li>
</ul>
<h4 id="打表">打表</h4>
<h4 id="two-pointers">two pointers</h4>
<h4 id="滑动窗口双指针">滑动窗口（双指针）</h4>
<p>设置头尾指针，维护两指针（当然，不需要用指针这么可怕的数据类型）间满足条件的序列。
可以很容易发现，当头指针在位置x时，如果获得的最远尾指针在位置y，那么当头指针后移到x+1位置时，尾指针只会停留在原地或是继续后移。
也就是说，这是一个单向移动的过程，时间复杂度就可以简化为O(N)啦！</p>
<h5 id="lc-3-无重复字符的最长字串">LC 3 无重复字符的最长字串</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 对于字符串长为0时特殊处理（这里需要这么做，是因为最后答案输出时是ans + 1</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//头尾下标指针初始化</span></span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>, en = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> ch[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// ch数组按照ASCII码的值记录每个字符是否已被使用</span></span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="literal">false</span>, <span class="built_in">sizeof</span>(ch));</span><br><span class="line">        <span class="comment">// 记录第一位的字符</span></span><br><span class="line">        ch[s[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 注意，因为String存储范围的下标其实是 0..(len-1)，因此全部处理成en + 1 &lt; len</span></span><br><span class="line">        <span class="keyword">while</span>(en + <span class="number">1</span> &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 利用贪心，如果下一位超出String范围，或是已被使用过，则退出循环</span></span><br><span class="line">            <span class="keyword">while</span>(en + <span class="number">1</span> &lt; len &amp;&amp; !ch[s[en + <span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                en ++;</span><br><span class="line">                ch[s[en]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于ans存储的是尾指针-头指针的数值，因此比实际长度小1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, en - st);</span><br><span class="line">            <span class="comment">// 头指针后移一位</span></span><br><span class="line">            ch[s[st]] = <span class="literal">false</span>;</span><br><span class="line">            st ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里使用ans + 1输出是为了将len = 1的情况一起包括进来，感兴趣的码友可以尝试一下此类数据</span></span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="前缀和差分">前缀和&amp;差分</h4>
<h4
id="二维grid上下左右移动的小trick">二维grid上下左右移动的小trick</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> direction[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> row, col;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> nextR = row + direction[i];</span><br><span class="line">    <span class="type">int</span> nextC = col + direction[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点数出现精度丢失的问题">浮点数出现精度丢失的问题</h4>
<p>如果浮点数的精度有限的话，可以将浮点数<span
class="math inline">\(\times 10 ^
n\)</span>使得浮点数化成整型，如果需要输出时，只需做一次转换即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数的比较</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b) &lt; <span class="number">1e-6</span>) cout &lt;&lt; <span class="string">&quot;a = b&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="数学基础">数学基础</h1>
<h2 id="生成函数">生成函数</h2>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16X4y1N74M?spm_id_from=333.337.search-card.all.click">生成函数：函数与数列之间的桥梁
(蒋炎岩)_bilibili</a></p>
<h3 id="引子">引子</h3>
<ul>
<li><p>多项式</p></li>
<li><p>递推公式：斐波那契数列</p></li>
<li><p>无穷小数：0.9999...</p></li>
<li><p>结论：一个生成函数里包含了一个无穷数列的每一项。</p></li>
</ul>
<h3 id="求fibonacci-数列">求Fibonacci 数列</h3>
<p><span class="math display">\[
Recursive Define\\
fib(0) = 0, \\
fib(1) = 1,\\
fib(n) = fib(n-1) + fib(n-2);\\
using 生成函数\\
1) F(x) = 0x^0 + 1x^1 + 1x^2 + 2x^3 + 3x^4 + \cdots\\
2)xF(x) = 1x^2 + 1x^3+2x^4 + 3x^5 +\cdots \\
3)x^2F(x) = 1x^3 + 1x^4+2x^5 + 3x^6 +\cdots \\
let (1) - (2) - (3), then \\
(1-x-x^2)F(x) = x\\ \Rightarrow
F(x) = {x\over{1-x-x^2}}\\
部分因式分解，\\
{x\over{1-x-x^2}} \\= \frac{-1-\sqrt{5}}{\sqrt{5}(2
x+\sqrt{5}+1)}+\frac{\sqrt{5}-1}{\sqrt{5}(-2 x+\sqrt{5}-1)}\\=some\
thing\ else +\frac{1}{\sqrt{5}}
\frac{1}{1-\left(\frac{1+\sqrt{5}}{2}\right) x}
\\再次利用生成函数的意义，\\
fib(n) = {1\over{\sqrt{5}}}\cdot{\left(\frac{1+\sqrt{5}}{2}\right)}^n x
+ similar\ one.
\]</span></p>
<h3 id="用函数-多项式代数-表示各种数列">用函数 (多项式代数)
表示各种数列</h3>
<blockquote>
<blockquote>
<ul>
<li><span class="math inline">\(c \cdot F(x) \rightarrow\)</span>
数列倍增</li>
<li><span class="math inline">\(x \cdot F(x) \rightarrow\)</span>
数列右移 (补 0 )</li>
<li><span class="math inline">\([F(x)-f(0)] / x \rightarrow\)</span>
数列左移</li>
<li><span class="math inline">\(F_{1}(x) \pm F_{2}(x)
\rightarrow\)</span> 数列求和/差</li>
<li><span class="math inline">\(F^{\prime}(x) \rightarrow\)</span>
数列乘幂次 <span class="math inline">\(+\)</span> 左移</li>
<li>导数:<span class="math inline">\((c)^{\prime}=0,\\
\left(x^{n}\right)^{\prime}=n x^{n-1}\)</span></li>
<li><span class="math inline">\(F_{1}(x) \cdot F_{2}(x)
\rightarrow\)</span> 数列卷积
<ul>
<li><span class="math inline">\(F(x)\cdot {1\over{1-x}}\)</span>为<span
class="math inline">\(F(x)\)</span>代表的数列的前n项和的生成函数</li>
</ul></li>
</ul>
</blockquote>
</blockquote>
<h2 id="乘法逆元">乘法逆元</h2>
<h3 id="从组合数c_nk-mod-p的快速求法说起">从组合数<span
class="math inline">\(C_n^k \mod p\)</span>的快速求法说起</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yunzinan.github.io">oys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yunzinan.github.io/post/c1c4cec.html">https://yunzinan.github.io/post/c1c4cec.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yunzinan.github.io" target="_blank">Yunzinan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/1baadb3a.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">dp专题</div></div></a></div><div class="next-post pull-right"><a href="/post/f14df9e6.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Calculus_II_midterm_review</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/1baadb3a.html" title="dp专题"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">dp专题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yunzinan-pic-bed.oss-cn-nanjing.aliyuncs.com/2022/05/doge.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">oys</div><div class="author-info__description">菜狗一枚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yunzinan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 刷题笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">知识学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cstl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">C++STL容器学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority_queue"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-unordered_set"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">set (unordered_set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">pair</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">algorithm头文件下的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">sort()函数的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stable_sort%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">stable_sort用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lower_bound-upper_bound"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">lower_bound &amp; upper_bound()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bst-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">BST 二叉搜索树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#avl%E6%A0%91-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">AVL树 平衡二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.3.2.4.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.1.3.2.4.1.</span> <span class="toc-text">路径压缩</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">1.1.3.2.5.</span> <span class="toc-text">字典树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.3.2.6.</span> <span class="toc-text">哈夫曼树（最优二叉树）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86lowbit%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.3.5.1.</span> <span class="toc-text">预备知识：lowbit()运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E6%B7%B1%E6%90%9Cdfs"><span class="toc-number">1.1.3.5.2.</span> <span class="toc-text">图的遍历：深搜（DFS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E5%B9%BF%E6%90%9Cbfs"><span class="toc-number">1.1.3.5.3.</span> <span class="toc-text">图的遍历：广搜（BFS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86a%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.3.5.4.</span> <span class="toc-text">图的遍历：\(A^*\)算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-minimal-spanning-tree-prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.3.5.5.</span> <span class="toc-text">最小生成树 (Minimal
Spanning Tree) ：prim算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mstkruskal%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.3.5.6.</span> <span class="toc-text">最小生成树（MST）：Kruskal算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.3.5.7.</span> <span class="toc-text">单源最短路径：Dijkstra算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.3.5.8.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%B1%82%E6%B3%95tarjan%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.3.5.9.</span> <span class="toc-text">强连通分量求法：Tarjan算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.1.3.5.10.</span> <span class="toc-text">图中是否存在环的判断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">排序和搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dp"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">dp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">蓄水池抽样</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E5%81%9A%E9%A2%98%E7%BB%8F%E9%AA%8C"><span class="toc-number">1.2.</span> <span class="toc-text">刷题记录（补充知识+做题经验）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86check"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">二分+check</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc5219-%E6%AF%8F%E4%B8%AA%E5%B0%8F%E5%AD%A9%E6%9C%80%E5%A4%9A%E8%83%BD%E5%88%86%E5%88%B0%E5%A4%9A%E5%B0%91%E7%B3%96%E6%9E%9C"><span class="toc-number">1.2.0.1.1.</span> <span class="toc-text">LC5219
每个小孩最多能分到多少糖果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-1"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text">LC150 逆波兰表达式求值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="toc-number">1.2.0.3.1.</span> <span class="toc-text">LC547 省份数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lc1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">1.2.0.3.2.</span> <span class="toc-text">LC1319
连通网络的操作次数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.0.4.1.</span> <span class="toc-text">LC889
根据前序和后序遍历构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91-1"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACk%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">1.2.0.5.1.</span> <span class="toc-text">LC440
字典序的第K小数字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BA%E5%BA%A6%E5%85%A5%E5%BA%A6"><span class="toc-number">1.2.0.6.1.</span> <span class="toc-text">出度、入度</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lc997-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98"><span class="toc-number">1.2.0.6.1.1.</span> <span class="toc-text">LC997
找到小镇的法官</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bfs"><span class="toc-number">1.2.0.6.2.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lc417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.6.2.1.</span> <span class="toc-text">LC417
太平洋大西洋水流问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#lc934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-number">1.2.0.6.2.2.</span> <span class="toc-text">LC934
最短的桥</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dijkstra--single-source-shortest-pathsssp-algorithm"><span class="toc-number">1.2.0.6.3.</span> <span class="toc-text">Dijkstra-
Single Source Shortest Path(SSSP) algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lc743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.0.6.3.1.</span> <span class="toc-text">LC743
网络延迟时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.2.0.7.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc599-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C"><span class="toc-number">1.2.0.7.1.</span> <span class="toc-text">LC599
两个列表的最小索引总和</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dp-1"><span class="toc-number">1.2.0.8.</span> <span class="toc-text">dp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc1575-%E7%BB%9F%E8%AE%A1%E6%89%80%E6%9C%89%E5%8F%AF%E8%A1%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.0.8.1.</span> <span class="toc-text">LC1575
统计所有可行路径</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.0.9.</span> <span class="toc-text">凸包算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%A2%98%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">读题与分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">打表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#two-pointers"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">two pointers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">滑动窗口（双指针）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lc-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2"><span class="toc-number">1.2.1.4.1.</span> <span class="toc-text">LC 3 无重复字符的最长字串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">前缀和&amp;差分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4grid%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%B0%8Ftrick"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">二维grid上下左右移动的小trick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">浮点数出现精度丢失的问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AD%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82fibonacci-%E6%95%B0%E5%88%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">求Fibonacci 数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%87%BD%E6%95%B0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BB%A3%E6%95%B0-%E8%A1%A8%E7%A4%BA%E5%90%84%E7%A7%8D%E6%95%B0%E5%88%97"><span class="toc-number">2.1.3.</span> <span class="toc-text">用函数 (多项式代数)
表示各种数列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83"><span class="toc-number">2.2.</span> <span class="toc-text">乘法逆元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%BB%84%E5%90%88%E6%95%B0c_nk-mod-p%E7%9A%84%E5%BF%AB%E9%80%9F%E6%B1%82%E6%B3%95%E8%AF%B4%E8%B5%B7"><span class="toc-number">2.2.1.</span> <span class="toc-text">从组合数\(C_n^k \mod p\)的快速求法说起</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/359b4150.html" title="WebCrawlingNotes">WebCrawlingNotes</a><time datetime="2022-09-02T15:01:45.000Z" title="发表于 2022-09-02 23:01:45">2022-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f1d501c7.html" title="一个小问题: 可积一定有原函数吗?">一个小问题: 可积一定有原函数吗?</a><time datetime="2022-07-10T07:53:36.000Z" title="发表于 2022-07-10 15:53:36">2022-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/c3bfd1c6.html" title="Jupyter notebook快速入门">Jupyter notebook快速入门</a><time datetime="2022-06-28T16:39:30.000Z" title="发表于 2022-06-29 00:39:30">2022-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/9c59c100.html" title="普通物理I复习笔记">普通物理I复习笔记</a><time datetime="2022-06-22T01:28:58.000Z" title="发表于 2022-06-22 09:28:58">2022-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/39a8bbff.html" title="马原复习提纲">马原复习提纲</a><time datetime="2022-06-14T13:59:26.000Z" title="发表于 2022-06-14 21:59:26">2022-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By oys</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">心情不好的时候,试试切换夜间模式,用鼠标给自己放几束烟花吧</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script src="/js/sun_moon.js" async></script><div class="aplayer no-destroy" data-id="2729240519" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>